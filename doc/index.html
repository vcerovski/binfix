<p><link href="markdown.css" rel="stylesheet" type="text/css"></link></p>

<h1>BINFIX</h1>

<p>Viktor Cerovski, Jan 2018.</p>

<p><a name="Introduction"></a></p>

<h2>Introduction</h2>

<p>BINFIX (blend from "Binary Infix") is a poweful infix syntax notation for
S-expressions of Common LISP ranging from simple arithmetic and logical
forms to whole programs.</p>

<p>It is in experimental phase with a few important new features still to come.
(more than 10 kLOC currently.)
There are a few important new features still to come.
One of them, available from v0.16, is use of a single <code>;</code> symbol as a
form-separating symbol in <a href="#LET ; progn example">implicit-progn</a>, <a href="#SETF expr-termination">expression
terminator</a> for SETFs, or as end of <a href="#LET ; examples">LET binds
symbol</a> or <a href="#Local functions">local functions definition</a>.
There is also <code>def</code>, for <a href="#def">defining things</a>.</p>

<p>The most recent one is the same priority OPs (since v0.20).</p>

<p>Once the rest of them have been implemented, BINFIX will go to RC and then to
reference 1.0 version.</p>

<hr />

<h2>Content</h2>

<ul>
<li><a href="#Instalation">Installation</a></li>
<li><a href="#Examples">Examples</a>
<ul>
<li><a href="#Arithmetic and logical expressions">Arithmetic and logical expressions</a></li>
<li><a href="#Consing">Consing</a></li>
<li><a href="#Lambdas, definitions and type annotations">Lambdas, definitions and type annotations</a>
<ul>
<li><a href="#lambda">lambda</a></li>
<li><a href="#Maps">Mappings</a></li>
<li><a href="#defun">defun</a></li>
<li><a href="#&amp;optional">&amp;optional</a></li>
<li><a href="#Local functions">Local functions</a></li>
<li><a href="#defmethod">defmethod</a></li>
<li><a href="#defmacro">defmacro</a></li>
<li><a href="#def">def</a></li>
<li><a href="#types">Type annotations, declarations and definitions</a></li>
<li><a href="#funtypes">Funtion types</a></li>
</ul></li>
<li><a href="#LETs">LETs</a></li>
<li><a href="#SETs">SETs</a></li>
<li><a href="#Implicit progn">Implicit <code>progn</code></a></li>
<li><a href="#<code>$</code>plitter"><code>$</code>plitter</a></li>
<li><a href="#Multiple-choice forms">Multiple-choice forms</a></li>
<li><a href="#Destructuring, multiple values">Destructuring, multiple values</a></li>
<li><a href="#Loops">Loops</a></li>
<li><a href="#Hash tables and association lists">Hash tables and association lists</a></li>
</ul></li>
<li><a href="#Indexing">Indexing</a></li>
<li><a href="#Mappings">Mappings</a></li>
<li><a href="#Bits">Working with bits</a></li>
<li><a href="#Support for macros">Support for macros</a></li>
<li><a href="#More involved examples">More involved examples</a>
<ul>
<li><a href="#ordinal">ordinal</a></li>
<li><a href="#join">join</a></li>
<li><a href="#values-bind">values-bind</a></li>
<li><a href="#for">for</a></li>
<li><a href="#Cartesian to polar coordinates">Cartesian to polar coordinates</a></li>
</ul></li>
<li><a href="#Implementation">Implementation</a>
<ul>
<li><a href="#proto-BINFIX">proto-BINFIX</a></li>
</ul></li>
<li><a href="#Appendix">Appendix</a>
<ul>
<li><a href="#Syntax-highlighting">Syntax highlighting</a></li>
<li><a href="#Operation properties">Operation properties</a></li>
<li><a href="#List of all operations">List of all operations</a></li>
</ul></li>
</ul>

<hr />

<p><a name="Instalation"></a></p>

<h2>Instalation</h2>

<p><a href="https://www.quicklisp.org/">Quicklisp</a> makes the
downloading/installation/loading trivial:</p>

<pre><code>(ql:quickload :binfix)
</code></pre>

<p>After loading the package, the next step is to allow use of its symbols</p>

<pre><code>(use-package :binfix)
</code></pre>

<p>BINFIX is developed using
<a href="https://en.wikipedia.org/wiki/Steel_Bank_Common_Lisp">SBCL</a>, and checked to
work fine with <a href="https://en.wikipedia.org/wiki/CLISP">CLISP</a>,
and <a href="https://en.wikipedia.org/wiki/Clozure_CL">Clozure CL</a>,
while with <a href="https://en.wikipedia.org/wiki/Embeddable_Common_Lisp">ECL</a> passes
tests when hand-loaded but does not go through the package system yet (tried
with v16.1.2).</p>

<p>BINFIX shadows <code>!</code> and <code>symbol-macrol</code> in CLISP , <code>@</code> in Clozure CL and ECL, as
well as <code>var</code> (<code>sb-debug:var</code>) in SBCL.</p>

<p>The latest version is available at <a href="https://github.com/vcerovski/binfix">gihub</a>,
and can be obtained by</p>

<pre><code>git clone https://github.com/vcerovski/binfix
</code></pre>

<p>There is also a syntax-highlighting file for <code>vim</code> editor, <code>binfix.vim</code>.
Its installation consists of copying it into vimrc/syntax folder, which is
on Linux located at <code>~/.vim/syntax</code> (should be created if it doesn't exist.)</p>

<p>Once installed, after loading a LISP file, LISP+BINFIX syntax highlighting
can be activated by <code>:set syntax=binfix</code>.  Loading can be done automatically
by adding</p>

<pre><code>filetype on
au BufNewFile,BufRead *.lisp,*.cl set syntax=binfix
</code></pre>

<p>to <code>.vimrc</code>.</p>

<p><a name="Examples"></a></p>

<h2>Examples</h2>

<p>Generally, quoting a BINFIX expression in REPL will produce the corresponding
S-expression.</p>

<p>For easier comparison of input and output forms in following examples, LISP
printer is first <code>setq</code> (operation <code>=.</code>) to lowercase output with</p>

<pre><code>{*print-case* =. :downcase}
</code></pre>

<p>=> <code>:downcase</code></p>

<p>BINFIX is a free-form notation (just like S-expr), i.e any number of empty
spaces (including tabs and newlines) between tokens is treated the same as a
single white space.</p>

<p><a name="Arithmetic and logical expressions"></a></p>

<h3>Arithmetic and logical expressions</h3>

<p>Classic math stuff:</p>

<pre><code>{2 * 3 + 4}
</code></pre>

<p>=> <code>10</code></p>

<pre><code>'{a * {b + c}}
</code></pre>

<p>=> <code>(* a (+ b c))</code></p>

<pre><code>'{- {x + y} / x * y}
</code></pre>

<p>=> <code>(- (/ (+ x y) (* x y)))</code></p>

<pre><code>'{0 &lt; x &lt; 1 &amp;&amp; y &gt;= 1 || y &gt;= 2}
</code></pre>

<p>=> <code>(or (and (&lt; 0 x 1) (&gt;= y 1)) (&gt;= y 2))</code></p>

<pre><code>'{- f x - g x - h x}
</code></pre>

<p>=> <code>(- (- (f x)) (g x) (h x))</code></p>

<p>Expressions like <code>{(f x y) * (g a b)}</code> and <code>{{f x y} * {g a b}}</code> generally
produce the same result. The inner brackets, however, can be removed:</p>

<pre><code>'{sqrt x * sin x}
</code></pre>

<p>=> <code>(* (sqrt x) (sin x))</code></p>

<pre><code>'{A ! i .= B ! j + C ! k}
</code></pre>

<p>=> <code>(setf (aref a i) (+ (aref b j) (aref c k)))</code></p>

<pre><code>'{a ! i j += b ! i k * c ! k j}
</code></pre>

<p>=> <code>(incf (aref a i j) (* (aref b i k) (aref c k j)))</code></p>

<pre><code>'{listp A &amp;&amp; car A == 'x &amp;&amp; cdr A || A}
</code></pre>

<p>=> <code>(or (and (listp a) (eql (car a) 'x) (cdr x)) a)</code></p>

<p><a name="Consing"></a></p>

<h3>Consing</h3>

<p>Operation <code>:.</code> stands for <code>cons</code>. For instance,</p>

<pre><code>{-2 :. loop for i to 9 collect i}
</code></pre>

<p>=> <code>(-2 0 1 2 3 4 5 6 7 8 9)</code></p>

<p>with the familiar behaviour:</p>

<pre><code>{1 :. 2 :. 3 equal '(1 2 . 3)}
</code></pre>

<p>=> <code>t</code></p>

<pre><code>{1 :. 2 :. 3 :. {} equal '(1 2 3)}
</code></pre>

<p>=> <code>t</code></p>

<p><a name="Lambdas, definitions and type annotations"></a></p>

<h3>Lambdas, definitions and type annotations</h3>

<p><a name="lambda"></a></p>

<h4><code>lambda</code></h4>

<pre><code>'{x -&gt; sqrt x * sin x}
</code></pre>

<p>=> <code>(lambda (x) (* (sqrt x) (sin x)))</code></p>

<pre><code>'{x :single-float -&gt; sqrt x * sin x}
</code></pre>

<p>=> <code>(lambda (x) (declare (type single-float x)) (* (sqrt x) (sin x)))</code></p>

<pre><code>'{x y -&gt; {x - y}/{x + y}}
</code></pre>

<p>=> <code>(lambda (x y) (/ (- x y) (+ x y)))</code></p>

<p>Mixing of notations works as well, so each of the following</p>

<pre><code>{x y -&gt; / (- x y) (+ x y)}
{x y -&gt; (- x y)/(+ x y)}
{x y -&gt; (/ (- x y) (+ x y))}
</code></pre>

<p>produces the same form.</p>

<p>Fancy way of writing <code>{2 * 3 + 4}</code></p>

<pre><code>{x -&gt; y -&gt; z -&gt; x * y + z @ 2 @ 3 @ 4}
</code></pre>

<p>=> <code>10</code></p>

<p>Quoting reveals the expanded S-expr</p>

<pre><code>'{x -&gt; y -&gt; z -&gt; x * y + z @ 2 @ 3 @ 4}
</code></pre>

<p>=></p>

<pre><code>(funcall (funcall (funcall
  (lambda (x) (lambda (y) (lambda (z) (+ (* x y) z))))
    2) 3) 4)
</code></pre>

<p>Indeed, <code>@</code> is left-associative, standing for <code>funcall</code>.</p>

<p>More complicated types can be also explicitely given after an
argument, </p>

<pre><code>'{x :|or symbol number| -&gt; x :. x}
</code></pre>

<p>=></p>

<pre><code>(lambda (x) (declare (type (or symbol number) x)) (cons x x))
</code></pre>

<p><a name="Maps"></a></p>

<h4><code>Mappings</code></h4>

<p><code>mapcar</code> is also supported:</p>

<pre><code>'{x -&gt; sin x * sqrt x @. (f x)}
</code></pre>

<p>=></p>

<pre><code>(mapcar (lambda (x) (* (sin x) (sqrt x))) (f x))
</code></pre>

<p>Alternatively, it is possible to use the expression-termination symbol <code>;</code>,</p>

<pre><code>{x -&gt; sin x * sqrt x @. f x;}
</code></pre>

<p>to the same effect.</p>

<p><code>reduce</code> is represented by <code>@/</code>,</p>

<pre><code>'{#'max @/ x y -&gt; abs{x - y} @. a b}
</code></pre>

<p>=></p>

<pre><code>(reduce #'max (mapcar (lambda (x y) (abs (- x y))) a b))
</code></pre>

<p>and other maps have their <code>@</code>'s as well.</p>

<p><a name="defun"></a></p>

<h4><code>defun</code></h4>

<p>Factorial fun:</p>

<pre><code>'{f n :integer := if {n &lt;= 0} 1 {n * f {1- n}}}
</code></pre>

<p>=></p>

<pre><code>(defun f (n)
  (declare (type integer n))
  (if (&lt;= n 0)
      1
      (* n (f (1- n)))))
</code></pre>

<p>Function documentation, local declarations, local bindings 
and comments have a straightforward syntax:</p>

<pre><code>'{g x := "Auxilary fn."
   declare (inline)
   let x*x = x * x; ;; Note binds termination via ;
     x*x / 1+ x*x}
</code></pre>

<p>=></p>

<pre><code>(defun g (x)
  "Auxilary fn."
  (declare (inline))
  (let ((x*x (* x x)))
    (/ x*x (1+ x*x))))
</code></pre>

<p><a name="&amp;optional"></a></p>

<h4><code>&amp;optional</code> is optional</h4>

<p>Explicitely tail-recursive version of <code>f</code></p>

<pre><code>'{fac n m = 1 :=
   declare (integer m n)
   if {n &lt;= 0} m
      {fac {n - 1} {n * m}}}
</code></pre>

<p>=></p>

<pre><code>(defun fac (n &amp;optional (m 1))
  (declare (integer m n))
  (if (&lt;= n 0)
      m
      (fac (- n 1) (* n m))))
</code></pre>

<p>As you may by now expect, the following is also permited</p>

<pre><code>{fac n :integer m :integer = 1 :=
  if {n &lt;= 0} m
     {fac {n - 1} {n * m}}}
</code></pre>

<p><em>supplied-p</em> variable <code>var</code> for an optional/keyword argument is given by <code>?var</code>
after the assignment.</p>

<p><code>{f x y = 0 ?supplied-y &amp;key z = 0 ?supplied-z :=</code><em><code>&lt;body expr&gt;</code></em><code>}</code>,</p>

<p>where, within <em><code>&lt;body expr&gt;</code></em>, boolean variables <code>supplied-y</code> and <code>supplied-z</code>
are available (for the standard check whether respective values were provided
in the call of <code>f</code>.)</p>

<p><a name="Local functions"></a></p>

<h4>Local functions</h4>

<p>Version of <code>fac</code> with a local recursive function <code>f</code>:</p>

<pre><code>{fac n :integer :=
  labels
    f n m := {if {n = 0} m
                 {f (1- n) {n * m}}}
   f n 1}
</code></pre>

<p>Another syntax to specify a local function is to use a single <code>;</code> as in</p>

<pre><code>{fac n :integer :=
  labels
    f n m := if {n = 0} m
                {f (1- n) {n * m}};
   f n 1}
</code></pre>

<!--
There is also yet another way to write the definition of `fac`, as

    {fac n :integer :=
      labels
        f n m := {if n = 0; m; f (1- n) {n * m}}
       f n 1}
-->

<p>All three above definitions of <code>fac</code> are transformed by <code>binfix</code> to</p>

<pre><code>(defun fac (n)
  (declare (type integer n))
  (labels ((f (n m)
             (if (= n 0)
                 m
                 (f (1- n) (* n m)))))
    (f n 1)))
</code></pre>

<p>which can be demonstrated by simply evaluating the quoted expressions.</p>

<p>The same syntax is used also in the case of <code>flet</code> and <code>macrolet</code>.</p>

<p><a name="defmethod"></a></p>

<h4><code>defmethod</code></h4>

<p>The following two generic versions of <code>f</code></p>

<pre><code>'{f n :integer :- if {n &lt;= 0} 1 {n * f {1- n}}}
'{f (n integer):- if {n &lt;= 0} 1 {n * f {1- n}}}
</code></pre>

<!--
    '{f n :integer :- {if n <= 0; 1;
                          n * f(1- n)}}
-->

<p>both produce</p>

<pre><code>(defmethod f ((n integer))
  (if (&lt;= n 0)
      1
      (* n (f (1- n)))))
</code></pre>

<p><code>:-</code> supports also eql-specialization via <code>==</code> op, analogous to
the way <code>=</code> is used for optional arguments initialization, as well as an
optional method qualifier, given as the first argument after the method name,
that can be either a keyword or an atom surrounded by parens (i.e <code>:around</code>,
<code>(reduce)</code> etc.)</p>

<p><a name="defmacro"></a></p>

<h4><code>defmacro</code></h4>

<p>Macros are defined via <code>:==</code> operation, similar to the previous examples.
See Sec. <a href="#Support for macros">Support for macros</a>.</p>

<p><a name="types"></a></p>

<h4>Type annotations, declarations and definitions</h4>

<p>The examples shown so far demonstrate the possibility to type-annotate
symbols in binds and lambda-lists by an (optional) keyword representing
the type (for instance <code>:fixnum</code>, <code>:my-class</code>, <code>:|simple-array single-float|</code>,
<code>:|or symbol number|</code>, <code>:|{symbol or number}|</code>, etc.)</p>

<p>OPs that represent LISP forms which allow declaration(s), in BINFIX can 
have in addition to the standard <code>(declare ...)</code> form also unparenthesized
variant:</p>

<pre><code>'{f x :fixnum y = 2 :=
   declare (inline)
   declare (fixnum y)
   x + y ** 2}
</code></pre>

<p>=></p>

<pre><code>(defun f (x &amp;optional (y 2))
  (declare (type fixnum x))
  (declare (inline))
  (declare (fixnum y))
  (+ x (expt y 2)))
</code></pre>

<p>Another way to declare <code>x</code> and <code>y</code> is</p>

<pre><code>'{f x y = 2 :=
   declare x y :fixnum
   declare (inline)
   x + y ** 2}
</code></pre>

<p>=></p>

<pre><code>(defun f (x &amp;optional (y 2))
  (declare (inline))
  (declare (fixnum x y))
  (+ x (expt y 2)))
</code></pre>

<p><a name="funtypes"></a></p>

<h4>Function types</h4>

<p>Operation <code>:-&gt;</code> can be used to specify function type. For example, in
SBCL 1.1.17 function <code>sin</code> has declared type that can be written as</p>

<pre><code>'{number :-&gt; single-float -1.0 1.0 ||
             double-float -1.0 1.0 ||
             complex single-float  ||
             complex double-float .x. &amp;optional}
</code></pre>

<p>=></p>

<pre><code>(function (number)
 (values
  (or (single-float -1.0 1.0)
      (double-float -1.0 1.0)
      (complex single-float)
      (complex double-float))
  &amp;optional))
</code></pre>

<p>Function <code>fac</code> with a local function from <a href="#Local functions">this example</a>
can have its type declared as</p>

<pre><code>'{fac n :integer :=
   labels
     f n m := if {n = 0} m
                 {f (1- n) {n * m}};
     declare f {integer integer :-&gt; integer}
    f n 1}
</code></pre>

<p>=></p>

<pre><code>(defun fac (n)
  (declare (type integer n))
  (labels ((f (n m)
             (if (= n 0)
                 m
                 (f (1- n) (* n m)))))
    (declare (ftype (function (integer integer) integer) f))
    (f n 1)))
</code></pre>

<p>Declaration which annotates that symbol value of a symbol is a function can be
achieved by using <code>-&gt;</code> instead of <code>:-&gt;</code> in declaration of the symbol.  For
instance:</p>

<pre><code>'{f x :integer :=
   let f = x -&gt; 1+ x;
     declare f {integer -&gt; integer}
   {flet f x := 1- x;
      declare f {integer :-&gt; integer}
      cons (f x) {f @ x}}}
</code></pre>

<p>=></p>

<pre><code>(defun f (x)
  (declare (type integer x))
  (let ((f (lambda (x) (1+ x))))
    (declare (type (function (integer) integer) f))
    (flet ((f (x)
             (1- x)))
      (declare (ftype (function (integer) integer) f))
      (cons (f x) (funcall f x)))))
</code></pre>

<p>which has the expected behavior:  <code>(f 0)</code> => <code>(-1 . 1)</code></p>

<p>Type definitions are given using <code>:type=</code> OP, as in</p>

<pre><code>`{mod n :type= `(integer 0 (,n))}
</code></pre>

<p>=></p>

<pre><code>(deftype mod (n) `(integer 0 (,n)))
</code></pre>

<p><a name="def"></a></p>

<h4><code>def</code></h4>

<p>Program typically consists of a number of definitions of functions,
constants, parameters, types, etc. The operation <code>def</code> is introduced
to facilitate their easy writing:</p>

<pre><code>'{def parameter *x* = 1 *y* = 2
  def struct point x y z
  def f x := sqrt x * sin x}
</code></pre>

<p>=></p>

<pre><code>(progn
 nil
 (defparameter *x* 1)
 (defparameter *y* 2)
 (defstruct point x y z)
 (defun f (x) (* (sqrt x) (sin x))))
</code></pre>

<p>As it is clear from the example, the definitions are wrapped up in <code>progn</code>.</p>

<p>More detailed definitions are also straightforward to specify:</p>

<pre><code>'{def parameter
    *x* :fixnum = 1
    *y* :fixnum = 2;

  struct point "Point"
    :print-function {p s d -&gt;
                       declare (ignore d)
                       with-slots (x y z) p
                         (format s "#&lt;~$ ~$ ~$&gt;" x y z)}
    :constructor create-point (x y z = 0f0)
    x :single-float = 0f0
    y :single-float = 0f0
    z :single-float = 0f0

  def f x :single-float :=
    declare (inline)
    sqrt x * sin x}
</code></pre>

<p>=></p>

<pre><code>(progn
 nil
 (declaim (type fixnum *x*)
          (type fixnum *y*))
 (defparameter *x* 1)
 (defparameter *y* 2)
 (defstruct
     (point
      (:print-function
       (lambda (p s d)
         (declare (ignore d))
         (with-slots (x y z)
             p
           (format s "#&lt;~$ ~$ ~$&gt;" x y z))))
      (:constructor create-point (x y &amp;optional (z 0.0))))
   "Point"
   (x 0.0 :type single-float)
   (y 0.0 :type single-float)
   (z 0.0 :type single-float))
 (defun f (x)
   (declare (inline))
   (declare (type single-float x))
   (* (sqrt x) (sin x))))
</code></pre>

<p><code>def class</code> syntax is like <code>defclass</code> without parens.  For this to work, class
options (<code>:documentation</code> and <code>:metaclass</code>) have to be given <em>before</em>
description of slots, while <code>:default-initargs</code> comes last as usual, just
unparenthesized (see <a href="#Cartesian to polar coordinates">example</a>.)</p>

<p><code>def</code>ining of symbols follows the same syntax as <code>let</code> binding, which
is covered next.</p>

<p><a name="LETs"></a></p>

<h3>LETs</h3>

<p>LET symbol-binding forms (<code>let</code>, <code>let*</code>, <code>symbol-macrolet</code>, etc) in BINFIX use
<code>=</code> with an optional type-annotation:</p>

<pre><code>'{let x :bit = 1
      y = {2 ** 3}
      z = 4
    x + y * z}
</code></pre>

<p>=></p>

<pre><code>(let ((x 1) (y (expt 2 3)) (z 4))
  (declare (type bit x))
  (+ x (* y z)))
</code></pre>

<p><a name="LET ; examples"></a>
A single <code>;</code> can be used as a terminator of bindings:</p>

<pre><code>'{let x :bit = 1
      y = 2 ** 3
      z = f a;
    x + y * z}
</code></pre>

<p>=></p>

<pre><code>(let ((x 1) (y (expt 2 3)) (z (f a)))
  (declare (type bit x))
  (+ x (* y z)))
</code></pre>

<p><a name="LET ; progn example"></a>
Finally, a single <code>;</code> can also be used to separate forms in implicit-progn,
as in</p>

<pre><code>'{let x :bit = 1
      y = 2 ** 3
      z = f a;         ;; end of binds
    print "Let binds"; ;; 1st form
    x + y * z}         ;; 2nd form of implicit-progn
</code></pre>

<p>=></p>

<pre><code>(let ((x 1) (y (expt 2 3)) (z (f a)))
  (declare (type bit x))
  (print "Let binds")
  (+ x (* y z)))
</code></pre>

<p><a name="LET associativity"></a>
Nesting of <code>let</code>s without parens follows the right-associativity</p>

<pre><code>'{let a = f x;
    if a
      (g x)
      let b = h x;
        f b}
</code></pre>

<p>=></p>

<pre><code>(let ((a (f x)))
  (if a
      (g x)
      (let ((b (h x)))
        (f b))))
</code></pre>

<p>Note the three levels of parens gone.</p>

<p><a name="SETs"></a></p>

<h3>SETs</h3>

<p>In addition to <code>=.</code>, <code>=...</code> and <code>.=</code> OPs representing, respectively, a single
<code>setq</code>, <code>multiple-value-setq</code> and <code>setf</code> assignment, multiple assignments via
SETs can be done using <code>=</code>,</p>

<pre><code>'{psetq x =   cos a * x + sin a * y
        y = - sin a * x + cos a * y}
</code></pre>

<p>=></p>

<pre><code>(psetq x (+ (* (cos a) x) (* (sin a) y))
       y (+ (- (* (sin a) x)) (* (cos a) y)))
</code></pre>

<p>If it is necessary to remove repeating <code>sin a</code> and <code>cos a</code>,
it is easy to use <code>let</code>,</p>

<pre><code>{let sin = sin a
     cos = cos a;
   psetq x =   cos * x + sin * y
         y = - sin * x + cos * y}
</code></pre>

<p>and in the case of SETF assignments, RHS are represented with a single
expression,</p>

<pre><code>'{psetf a ! 0 = {a ! 1}
        a ! 1 = {a ! 0}}
</code></pre>

<p>=></p>

<pre><code>(psetf (aref a 0) (aref a 1)
       (aref a 1) (aref a 0))
</code></pre>

<p><a name="SETF expr-termination"></a>
Alternatively, it is possible to use a single <code>;</code> as an expression-termination
symbol,</p>

<pre><code>'{psetf a ! 0 = a ! 1; ;; expr. termination via single ;
        a ! 1 = a ! 0}
</code></pre>

<p>=></p>

<pre><code>(psetf (aref a 0) (aref a 1)
       (aref a 1) (aref a 0))
</code></pre>

<p>It is also possible to mix infix SETFs with other expressions:</p>

<pre><code>'{f x + setf a = b
             c = d;
      * h a c}
</code></pre>

<p>=></p>

<pre><code>(+ (f x)
   (*
    (setf a b
          c d)
    (h a c)))
</code></pre>

<p><a name="Implicit progn"></a></p>

<h3>Implicit <code>progn</code></h3>

<p>An implicit <code>progn</code> in BINFIX is achieved with a single <code>;</code> separating the
forms forming the progn.  In all cases (<code>-&gt;</code>, <code>:=</code>, <code>:-</code> and LETs) the syntax
is following that of the <a href="#LET ; progn example">LET example above</a>.</p>

<p>As expected, other <code>prog</code>s have to be explicitly given,</p>

<pre><code>'{x -&gt; prog2 (format t "Calculating... ")
             {f $ x * x}
             (format t "done.~%")}
</code></pre>

<p>or</p>

<pre><code>'{x -&gt; prog2
         format t "Calculating... ";
         f {x * x};
         format t "done.~%"}
</code></pre>

<p>both producing the following form</p>

<pre><code>(lambda (x)
  (prog2 (format t "Calculating... ") (f (* x x)) (format t "done.~%")))
</code></pre>

<p>Since BINFIX is a free-form notation, the following one-liner also works:</p>

<pre><code>'{x -&gt; prog2 format t "Calculating... "; f{x * x}; format t "done.~%"}
</code></pre>

<p>Binfix <code>&lt;&amp;</code> stands for <code>prog1</code>,</p>

<pre><code>'{x -&gt; {f {x * x} &lt;&amp;
        format t "Calculation done.~%"}}
</code></pre>

<p>=></p>

<pre><code>(lambda (x) (prog1 (f (* x x)) (format t "Calculation done.~%")))
</code></pre>

<p>while <code>multiple-value-prog1</code> is given by <code>&lt;&amp;..</code>.</p>

<p><a name="<code>$</code>plitter"></a></p>

<h3><code>$</code>plitter</h3>

<p>Infix <code>$</code> is a vanishing OP, leaving only its arguments,
effectivelly splitting the list in two parts.</p>

<pre><code>'{f $ g $ h x y z}
</code></pre>

<p>=> <code>(f (g (h x y z)))</code></p>

<p>So its effect here is similar to <code>$</code> in Haskell. 
Or perphaps:</p>

<pre><code>'{declare $ optimize (speed 1) (safety 1)}
</code></pre>

<p>=> <code>(declare (optimize (speed 1) (safety 1)))</code></p>

<p><code>$</code>plitter also allows writing a shorter <code>cond</code>, as in</p>

<pre><code>(cond {p x $ f x}
      {q x $ g x}
      {r x $ h x}
      {t $ x})
</code></pre>

<p>compared to the equivalent</p>

<pre><code>(cond ((p x) (f x))
      ((q x) (g x))
      ((r x) (h x))
      (t x))
</code></pre>

<p>Another splitter is <code>?</code>, which can be used instead of <code>$</code> in the previous
example, as well as described in the next section.</p>

<p><a name="Multiple-choice forms"></a></p>

<h3>Multiple-choice forms (<code>cond</code>, <code>case</code>, ...)</h3>

<p>An alternative syntax to describe multiple-choice forms is to use <code>?</code> and <code>;</code></p>

<pre><code>{cond p x ? f x;
      q x ? g x;
      r x ? h x;
        t ? x}
</code></pre>

<p>See also <a href="#ordinal"><code>ordinal</code> example below</a>.</p>

<p><a name="Destructuring, multiple values"></a></p>

<h3>Destructuring, multiple values</h3>

<p>Multiple values (<code>values</code>) are represented by <code>.x.</code>, 
<code>multiple-value-bind</code> by <code>=..</code> , and <code>destructuring-bind</code> by <code>..=</code></p>

<pre><code>'{a (b) c ..= (f x) a + 1 .x. b + 2 .x. c + 3}
</code></pre>

<p>=></p>

<pre><code>(destructuring-bind (a (b) c) (f x) (values (+ a 1) (+ b 2) (+ c 3)))
</code></pre>

<p>Another way to write the same expr:</p>

<pre><code>'{a (b) c ..= (f x) values a + 1; b + 2; c + 3}
</code></pre>

<p><code>multiple-value-call</code> is represented by <code>.@.</code></p>

<pre><code>'{#'list .@. 1 '(b 2) 3}
</code></pre>

<p>=></p>

<pre><code>(multiple-value-call #'list 1 '(b 2) 3)
</code></pre>

<p>=></p>

<pre><code>(1 (b 2) 3)
</code></pre>

<p>Both <code>..=</code> and <code>=..</code> can be nested,</p>

<pre><code>'{a b c =.. (f x)
  x y z =.. (g z)
  a * x + b * y + c * z}
</code></pre>

<p>=></p>

<pre><code>(multiple-value-bind (a b c)
    (f x)
  (multiple-value-bind (x y z) (g z) (+ (* a x) (* b y) (* c z))))
</code></pre>

<p><code>multiple-value-setq</code> is given by <code>=...</code></p>

<p><a name="Loops"></a></p>

<h4>Loops</h4>

<p>Loops can be also nested without writing parens:</p>

<pre><code>'{loop for i = 1 to 3
       collect loop for j = 2 to 4
                    collect {i :. j}}
</code></pre>

<p>=></p>

<pre><code>(loop for i = 1 to 3
      collect (loop for j = 2 to 4
                    collect (cons i j)))
</code></pre>

<p><a name="Hash tables and association lists"></a></p>

<h4>Hash tables and association lists</h4>

<p>Hash tables are supported in binfix through OPs <code>~!</code> (<code>gethash</code>),
<code>~~</code> (<code>remhash</code>) and <code>@~</code> (<code>maphash</code>).</p>

<p>Association lists are accessible via <code>!~~</code> (<code>assoc</code>) and <code>~~!</code> (<code>rassoc</code>).</p>

<p><a name="Mappings"></a></p>

<h3>Mappings</h3>

<p>Mappings and function applications are what <code>@</code>-ops are all about,
as summarized in the following table,</p>

<table>
  <tr><td>  <code>@</code></td>  <td><code>funcall</code></td></tr>
  <tr><td>  <code>@.</code></td> <td><code>mapcar</code></td></tr>
  <tr><td>  <code>@..</code></td><td><code>maplist</code></td></tr>
  <tr><td>  <code>@n</code></td> <td><code>mapcan</code></td></tr>
  <tr><td>  <code>@.n</code></td><td><code>mapcon</code></td></tr>
  <tr><td> <code>.@</code></td>  <td><code>mapc</code></td></tr>
  <tr><td><code>..@</code></td>  <td><code>mapl</code></td></tr>
  <tr><td>  <code>@/</code></td> <td><code>reduce</code></td></tr>
  <tr><td>  <code>@~</code></td> <td><code>maphash</code></td></tr>
  <tr><td>  <code>@@</code></td> <td><code>apply</code></td></tr>
  <tr><td> <code>.@.</code></td> <td><code>multiple-value-call</code></td></tr>
</table>

<p>They all have the same priority and are right-associative, and, since
they bind weaker than <code>-&gt;</code>, are easy to string together with lambdas,
as in a map-reduce expr.</p>

<p><code>{'max @/ x y -&gt; abs{x - y} @. a b}</code></p>

<p><a name="Indexing"></a></p>

<h3>Indexing</h3>

<p>The following table summarizes BINFIX OPs for indexing, from
the weakest to the strongest binding OP:</p>

<table>
  <tr><td><code>th-cdr</code></td>  <td><code>nthcdr</code></td>   </tr>
  <tr><td><code>th-bit</code></td>  <td><code>logbitp</code></td>  </tr>
  <tr><td><code>!..</code> &nbsp;
          <code>th-value</code></td><td><code>nth-value</code></td></tr>
  <tr><td><code>!.</code></td>      <td><code>svref</code></td>    </tr>
  <tr><td><code>.!</code></td>      <td><code>elt</code></td>      </tr>
  <tr><td><code>th</code></td>      <td><code>nth</code></td>      </tr>
  <tr><td><code>!!.</code></td>     <td><code>row-major-aref</code></td></tr>
  <tr><td><code>.!!.</code></td>    <td><code>bit</code></td>      </tr>
  <tr><td><code>!!</code></td>      <td><code>aref</code></td>     </tr>
  <tr><td><code>~!</code>
          <code>!~~</code>
          <code>~~!</code></td>     <td><code>gethash</code>
                                        <code>assoc</code>
                                        <code>rassoc</code></td>   </tr>
  <tr><td><code>.!.</code></td>     <td><code>bit</code></td>      </tr>
  <tr><td><code>!</code></td>       <td><code>aref</code></td>     </tr>
</table>

<p><code>!..</code> and <code>th-value</code> are mere synonyms and thus of the same priority, as are
<code>.!</code> <code>!.</code> and <code>!!.</code>, while <code>!!</code>
is a weaker binding <code>!</code>, allowing easier writting of expr. with arithmetic
operations with indices, like</p>

<p><code>{a !! i + j}</code></p>

<p><code>{a !! i + j; 1- k;}</code></p>

<p>etc.  In the same relation stand <code>.!.</code> and <code>.!!.</code></p>

<p><a name="Bits"></a></p>

<h3>Working with bits</h3>

<p>Integer bit-logical BINFIX ops are given with a <code>.</code> after the name of OP,
while bit-array version of the same OP with <code>.</code> before and after the name.
For instance, <code>{a or. b}</code> transforms to <code>(logior a b)</code>, while
<code>{a .or. b}</code> transforms to <code>(bit-ior a b)</code>.</p>

<p><a name="Support for macros"></a></p>

<h3>Support for macros</h3>

<p>If BINFIX terms <em>only</em> are inserted under backquote, everything should work
fine, </p>

<pre><code>'{let t1 = 'x
      t2 = '{x + x}
     `{x -&gt; ,t1 / ,t2}}
</code></pre>

<p>=></p>

<pre><code>(let ((t1 'x) (t2 '(+ x x)))
  `(lambda (x) (/ ,t1 ,t2)))
</code></pre>

<p>Replacing, however, BINFIX operations inside a backquoted BINFIX will <em>not</em>
work.  This is currently not considered as a problem because direct call of
<code>binfix</code> will cover some important cases of macro transformations in a 
straightforward manner:</p>

<pre><code>{m x y op = '/ type = :double-float :==
   let a = (gensym)
       b = (gensym)
     binfix `(let ,a ,type = ,x
                  ,b ,type = ,y
                {,a - ,b} ,op {,a + ,b})}
</code></pre>

<p>Now macro <code>m</code> works as expected:</p>

<pre><code>(macroexpand-1 '(m (f x y) {a + b}))
</code></pre>

<p>=></p>

<pre><code>(let ((#:g805 (f x y)) (#:g806 (+ a b)))
  (declare (type double-float #:g806)
           (type double-float #:g805))
  (/ (- #:g805 #:g806) (+ #:g805 #:g806)))
t
</code></pre>

<p>or,</p>

<pre><code>(macroexpand-1 '(m (f x y) {a + b}) * :double-float)
</code></pre>

<p>=></p>

<pre><code>(let ((#:g817 (f x y)) (#:g818 (+ a b)))
  (declare (type double-float #:g817)
           (type double-float #:g818))
  (* (- #:g817 #:g818) (+ #:g817 #:g818)))
t
</code></pre>

<p>See more in <a href="#binfix macros">implementation details</a></p>

<p><a name="More involved examples"></a></p>

<h3>More involved examples</h3>

<p><a name="ordinal"></a></p>

<h4><code>ordinal</code></h4>

<p>Converting an integer into ordinal string in English can be defined as</p>

<pre><code>{ordinal i :integer :=
   let* a = i mod 10
        b = i mod 100
      suf = {cond
               a = b = 1 || a = 1 &amp;&amp; 21 &lt;= b &lt;= 91 ? "st";
               a = b = 2 || a = 2 &amp;&amp; 22 &lt;= b &lt;= 92 ? "nd";
               a = b = 3 || a = 3 &amp;&amp; 23 &lt;= b &lt;= 93 ? "rd";
                                                t  ? "th"}
        format () "~D~a" i suf}
</code></pre>

<p>It can be also written in a more "lispy" way without parens as</p>

<pre><code>{ordinal1 i :integer :=
   let* a = i mod 10
        b = i mod 100
      suf = {cond
               = a b 1 or = a 1 and &lt;= b 21 91 ? "st";
               = a b 2 or = a 2 and &lt;= b 22 92 ? "nd";
               = a b 3 or = a 3 and &lt;= b 23 93 ? "rd";
                                            t  ? "th"}
        format () "~D~a" i suf}
</code></pre>

<p>which can be tried using <code>@.</code> (<code>mapcar</code>)</p>

<pre><code>{#'ordinal @. '(0 1 12 22 43 57 1901)}
</code></pre>

<p>=> <code>("0th" "1st" "12th" "22nd" "43rd" "57th" "1901st")</code></p>

<p>(This example is picked up from <a href="http://blog.rust-lang.org/2015/04/17/Enums-match-mutation-and-moves.html">Rust
blog</a>)</p>

<p><a name="join"></a></p>

<h4><code>join</code></h4>

<p>APL-ish joining of things into list:</p>

<pre><code>{
  defgeneric join (a b) &amp;

  join a :list  b :list :- append a b        &amp;
  join a :t     b :list :- cons a b          &amp;
  join a :list  b :t    :- append a (list b) &amp;
  join a :t     b :t    :- list a b          &amp;

  defbinfix '++ 'join 
}
; Must close here in order to use ++

{let e = '{2 in 'x ++ '(1 2 3) ++ '((a)) ++ -1 * 2}
    format t "~S~%=&gt; ~S" e (eval e)}
</code></pre>

<p>Evaluation of the above returns <code>t</code> and prints the following</p>

<pre><code>(member 2 (join 'x (join '(1 2 3) (join '((a)) (* -1 2)))))
=&gt; (2 3 (a) -2)
</code></pre>

<p>Another way to write <code>join</code> in BINFIX is as a single <code>defgeneric</code> definition, using <code>def generic</code>,</p>

<pre><code>{def generic join a b;
   "Generic join."
   a :list b :list :- append a b;
   a :t    b :list :- a :. b;
   a :list b :t    :- `(,@a ,b);
   a :t    b :t    :- list a b}
</code></pre>

<p>which expands into</p>

<pre><code>(progn
 (defgeneric join
     (a b)
   (:documentation "Generic join.")
   (:method ((a list) (b list)) (append a b))
   (:method ((a t) (b list)) (cons a b))
   (:method ((a list) (b t)) `(,@a ,b))
   (:method ((a t) (b t)) (list a b))))
</code></pre>

<p><a name="values-bind"></a></p>

<h4><code>values-bind</code></h4>

<p>Macro <code>multiple-value-bind</code> with symbol <code>_</code> in variable list standing for
an ignored value can be defined as</p>

<pre><code>{values-bind v e &amp;rest r :==
  let*  _ = ()
     vars = a -&gt; if {a == '_} {car $ push (gensym) _} a @. v;
    `(multiple-value-bind ,vars ,e
        ,@{_ &amp;&amp; `({declare $ ignore ,@_})}
        ,@r)}
</code></pre>

<p>So, for instance,</p>

<pre><code>(macroexpand-1 '(values-bind (a _) (truncate 10 3) a))
</code></pre>

<p>=></p>

<pre><code>(multiple-value-bind (a #:g823) (truncate 10 3) (declare (ignore #:g823)) a)
t
</code></pre>

<p><a name="for"></a></p>

<h4><code>for</code></h4>

<p>Nested BINFIX lambda lists can be used in definitions of macros, as in the
following example of a procedural for-loop macro</p>

<pre><code>{for (v :symbol from below by = 1) &amp;rest r :==
  `(loop for,v fixnum from,from below,below ,@{by /= 1 &amp;&amp; `(by,by)}
         do ,@r)}
</code></pre>

<p>Now</p>

<pre><code>(macroexpand-1 '(for (i 0 n)
                  {a ! i .= 1+ i}))
</code></pre>

<p>=></p>

<pre><code>(loop for i fixnum from 0 below n
      do (setf (aref a i) (1+ i)))
t
</code></pre>

<p><a name="Cartesian to polar coordinates"></a></p>

<h4>Cartesian to polar coordinates</h4>

<p>An example from <em>Common LISP the Language 2nd ed.</em> where cartesian
coordinates are converted into polar coordinates via change of class can be
straightforwardly written in BINFIX as</p>

<pre><code>{def class position () ();

     class x-y-position (position) 
      x :initform 0 :initarg :x  
      y :initform 0 :initarg :y;

     class rho-theta-position (position) 
      rho :initform 0
      theta :initform 0

 def update-instance-for-different-class :before 
      old :x-y-position
      new :rho-theta-position &amp;key :-
      ;; Copy the position information from old to new to make new 
      ;; be a rho-theta-position at the same position as old. 
        let x = slot-value old 'x 
            y = slot-value old 'y;
          slot-value new 'rho .= sqrt {x * x + y * y};
          slot-value new 'theta .= atan y x

;;; At this point an instance of the class x-y-position can be 
;;; changed to be an instance of the class rho-theta-position 
;;; using change-class: 

&amp; p1 =. make-instance 'x-y-position :x 2 :y 0

&amp; change-class p1 'rho-theta-position

;;; The result is that the instance bound to p1 is now 
;;; an instance of the class rho-theta-position. 
;;; The update-instance-for-different-class method 
;;; performed the initialization of the rho and theta 
;;; slots based on the values of the x and y slots, 
;;; which were maintained by the old instance.
}
</code></pre>

<p>where Steele's comments are left verbatim.</p>

<p><a name="Implementation"></a></p>

<h2>Implementation</h2>

<p>BINFIX expression is written as a list enclosed in curly brackets <code>{</code> ... <code>}</code>
handled through LISP reader, so the usual syntax rules of LISP apply, e.g <code>a+b</code>
is a single symbol, while <code>a + b</code> is three symbols.  Lisp reader after
tokenization calls the function <code>binfix</code> which does shallow transformation of
BINFIX into S-expr representation of the expression.</p>

<p>BINFIX uses a simple rewrite algorithm that divides a list in two, LHS and RHS
of the lowest priority infix operator found within the list, then recursively
processes each one.</p>

<p><a name="proto-BINFIX"></a></p>

<h3>proto-BINFIX</h3>

<p>Bootstraping is done beginning with proto-BINFIX,</p>

<pre><code>(defparameter *binfix*
  '((|;|    infix     (progn))
    (:==    def       defmacro)
    (:=     def       defun)
    (:-     def       defmethod)
    ( =.    infix     (setq))
    (.=     infix     (setf))
    (-&gt;     def-lambda)
    ($      infix     ())
    (symbol-macrolet  let= symbol-macrolet)
    (let    let=      let)
    (let*   let=      let*)
    (labels flet=     labels)
    (=..    var-bind  multiple-value-bind)
    (.x.    unreduc   .x. values)
    (:.     infix     (cons))
    (||     infix     (or))
    (&amp;&amp;     infix     (and))
    (==     infix     (eql))
    (=c=    infix     (char=))
    (in     infix     (member))
    ( !     infix     (aref))))

(defun binfix (e &amp;optional (ops *binfix*))
  (cond ((atom e) e)
        ((null ops) (if (cdr e) e (car e)))
        (t (let* ((op (car ops))
                  (op.rhs (member (pop op) e)))
             (if (null op.rhs)
               (binfix e (cdr ops))
               (let ((lhs (ldiff e op.rhs)))
                 (macroexpand-1
                   `(,@op ,lhs ,(cdr op.rhs)))))))))

(defmacro infix (op lhs rhs)
  `(,@op ,(binfix lhs) ,(binfix rhs)))

(set-macro-character #\{
  (lambda (s ch) (declare (ignore ch))
    (binfix (read-delimited-list #\} s t))))

(set-macro-character #\} (get-macro-character #\) ))
</code></pre>

<p>which captures the basics of BINFIX.</p>

<p>Since v0.15, BINFIX interns a symbol consisting of a single <code>;</code> char not
followed by <code>;</code> char, while two or more consequtive <code>;</code> are interpreted
as a usual LISP comment.  This behavior is limited to BINFIX
expressions only, while outside of them the standard LISP rules apply.</p>

<p>The next bootstrap phase defines macros <code>def</code>, <code>def-lambda</code>, <code>let=</code>,
<code>flet=</code>, <code>unreduc</code> and <code>var-bind</code>, done in <code>proto1.lisp</code>,</p>

<pre><code>{defmacro def (what args body)
  `(,what ,@(if (atom args)
               `(,args ())
               `(,(car args),(cdr args)))
          ,(binfix body));

 def-lambda args body :==
  `(lambda ,(if (consp args) args `(,args))
     ,(binfix body));

 let= let lhs body &amp;aux vars :==
  loop while {cadr body == '=}
     do {push `(,(car body),(caddr body)) vars;
         body =. cdddr body}
     finally (return (let ((let `(,let ,(nreverse vars) ,(binfix body))))
                       (if lhs (binfix `(,@lhs ,let)) let)));

 flet= flet lhs body &amp;aux funs :==
  loop for r = {'= in body} while r
       for (name . lambda) = (ldiff body r)
       do {push `(,name ,lambda ,(cadr r)) funs;
           body =. cddr r}
       finally {return let flet = `(,flet ,(reverse funs) ,(binfix body))
                         if lhs (binfix `(,@lhs ,flet)) flet};

 unreduc op op-lisp lhs rhs :==
   labels
     unreduce e &amp;optional args arg =
       (cond {null e      $ nreverse {binfix (nreverse arg) :. args}}
             {car e == op $ unreduce (cdr e) {binfix (nreverse arg) :. args}}
             {t           $ unreduce (cdr e) args {car e :. arg}})
   `(,op-lisp ,@(unreduce rhs `(,(binfix lhs))));

 var-bind op lhs rhs :== `(,op ,lhs ,(car rhs) ,(binfix (cdr rhs)))}
</code></pre>

<p>which wraps up proto-BINFIX.</p>

<p>Since v0.15, BINFIX interns a symbol consisting of a single <code>;</code> char not
followed by <code>;</code> char, while two or more consequtive <code>;</code> are interpreted
as starting a comment.  This behavior is limited to BINFIX
expressions only, while outside of them the standard LISP rules apply.</p>

<p>The rest is written using proto-BINFIX syntax, and consists of handling of
lambda lists and <code>let</code>s, a longer list of OPs with properties, redefined
<code>binfix</code> to its full capability, and, finally, several interface functions for
dealing with OPs (<code>lsbinfix</code>, <code>defbinfix</code> and <code>rmbinfix</code>).</p>

<p>Priorities of operations in proto-BINIFIX are given only relatively, with no
numerical values and thus with no two operations of the same priority.</p>

<p>Lhs and rhs of proto-BINFIX expressions refer to other proto-BINFIX
expressions (since v0.22.3), which in particular means that there is
no implicit-progn in proto-BINFIX let's and def's.</p>

<p>Since v0.20, symbol of a BINFIX operation has a list of properties stored into
the symbol property <code>binfix::properties</code>, which includes a numerically given
priority of the OP (which also considerably speeds up parsing.) The actual
value of number representing priority is supposed to be immaterial since only
relation to other OPs priority values is relevant.  Defining new same-priority
OPs should be done via <code>defbinfix</code> with <code>:as</code> option, which may change priority
values of many other OPs.</p>

<p><a name="binfix macros"></a>
Since shallow transformation into standard syntax is done by function <code>binfix</code>
invoked recursively by the reader, <code>binfix</code> cannot be directly called for
arbitrary macro transformation of BINFIX into BINFIX when standard macro
helpers BACKTICK, COMA and COMA-AT are used. The reason is that <code>{</code>...<code>}</code> is
invoked before them while the correct order would be after them.
Examples of succesful combinations of backquoting and BINFIX are given
<a href="#Support for macros">above</a>.</p>

<p><a name="Appendix"></a></p>

<h2>Appendix</h2>

<p><a name="Syntax-highlighting"></a></p>

<h3>Syntax highlighting</h3>

<p>Provided <code>binfix.vim</code> file covers <code>vim</code> editor with a syntax-highlighting
extension, which is based and dependends on <code>lisp.vim</code> that comes 
bundled with <code>vim</code>.</p>

<p>Here are gui and terminal looks:</p>

<p><img src="syntax-gui.png" alt="gui" title="" />
(theme: <code>solarized</code>, font: <code>Inconsolata Medium</code>)</p>

<p><img src="syntax-term.png" alt="terminal" title="" />
(theme: <code>herald</code>, font: <code>Terminus</code>)</p>

<p><a name="Operation properties"></a></p>

<h3>Operation properties</h3>

<p><code>:def</code> -- Operation (OP) is a definition requiring LHS to has a name and lambda
list.</p>

<p><code>:defm</code> -- OP is a definition requiring LHS to have a name followed by
unparenthesized method lambda list.</p>

<p><code>:lhs-lambda</code> -- OP has lambda list as its LHS.</p>

<p><code>:rhs-lbinds</code> -- OP has let-binds at the beginning of its RHS,<br>
[<em>symbol</em> [<em>keyword</em>] <strong><code>=</code></strong> <em>expr</em>]* <em>declaration</em>*</p>

<p><code>:rhs-fbinds</code> -- OP has flet-binds at the beginning of its LHS, including
optional declarations.</p>

<p><code>:rhs-sbinds</code> -- OP has symbol-binds as its RHS. They are let-binds without
annotations or declarations.</p>

<p><code>:rhs-ebinds</code> -- OP has expr-binds at the beginning of its RHS.</p>

<p><code>:unreduce</code> -- All appearances of OP at the current level should be unreduced,
i.e replaced with a single call with multiple arguments.</p>

<p><code>:left-assoc</code> -- OP is left--associative (OPs are right-associative by default.)</p>

<p><code>:prefix</code> -- OP is prefix with RHS being its arguments, given as one or more
atoms/S-expr or a single <code>;</code> separated B-expr.</p>

<p><code>:also-prefix</code> -- OP can be used as prefix when LHS is missing.</p>

<p><code>:also-unary</code> -- OP can be used as unary when LHS is missing.</p>

<p><code>:also-postfix</code> -- OP can be used as postfix when RHS is missing.</p>

<p><code>:lambda/expr</code> -- OP takes lambda-list at LHS and an expression at RHS, followed by body.</p>

<p><code>:syms/expr</code> -- OP takes a list of symbols as LHS (each with an optional
<a href="#types">keyword-type</a> annotation,) an expression as RHS followed
by optional declarations and a BINFIX-expression.</p>

<p><code>#'my-fun</code> -- function <code>my-fun</code> will be applied to the untransformed RHS.</p>

<p><code>:split</code> -- OP splits the expr at this point.</p>

<p><code>:rhs-args</code> -- OP takes LHS as 1st and RHS as remaining arguments.</p>

<p><code>:lhs-quote</code> -- OP quotes LHS.</p>

<p><code>:macro</code> -- OP is a macro.</p>

<p><code>:single</code> -- OP requires to be the only OP in the current expr with its
priority.  For example, parsing of: <code>{values a  b .x. c}</code> reports an ambiguity error.
<a name="List of all operations"></a></p>

<h3>List of all operations</h3>

<p>Command</p>

<pre><code>(lsbinfix)
</code></pre>

<p>prints the table of all BINFIX OPs and their properties from the weakest-
to the strongest-binding OP, with parens enclosing OP(s) of the same priority:</p>

<pre><code>  BINFIX         LISP            Properties
==============================================================================
( &lt;&amp;             prog1
  &lt;&amp;..           multiple-value-prog1 )
( &amp;              progn           :unreduce )
( def            binfix::defs    :macro )
( let            let             :rhs-lbinds
  let*           let*            :rhs-lbinds
  symbol-macrolet                symbol-macrolet :rhs-lbinds
  prog*          prog*           :rhs-lbinds
  prog           prog            :rhs-lbinds )
( macrolet       macrolet        :rhs-fbinds
  flet           flet            :rhs-fbinds
  labels         labels          :rhs-fbinds )
( :==            defmacro        :def
  :=             defun           :def
  :-             defmethod       :defm
  :type=         deftype         :def )
( block          block           :prefix
  tagbody        tagbody         :prefix
  catch          catch           :prefix
  prog1          prog1           :prefix
  prog2          prog2           :prefix
  progn          progn           :prefix
  cond           cond            :prefix
  case           case            :prefix
  ccase          ccase           :prefix
  ecase          ecase           :prefix
  typecase       typecase        :prefix
  etypecase      etypecase       :prefix
  ctypecase      ctypecase       :prefix )
( ?              nil             :split )
( $              nil             :split )
( =...           multiple-value-setq             :lhs-quote )
( .=             setf
  +=             incf
  -=             decf
  =.             setq
  .=.            set )
( setq           setq            :rhs-sbinds
  set            set             :rhs-sbinds
  psetq          psetq           :rhs-sbinds )
( setf           setf            :rhs-ebinds
  psetf          psetf           :rhs-ebinds )
( .@             mapc            :rhs-args
  ..@            mapl            :rhs-args
  @/             reduce          :rhs-args
  @.             mapcar          :rhs-args
  @..            maplist         :rhs-args
  @n             mapcan          :rhs-args
  @.n            mapcon          :rhs-args
  @~             maphash
  @@             apply           :rhs-args
  .@.            multiple-value-call             :rhs-args
  @              funcall         :rhs-args       :left-assoc     :also-postfix )
( :-&gt;            function        :lhs-lambda )
( -&gt;             lambda          :lhs-lambda )
( =..            multiple-value-bind             :syms/expr )
( ..=            destructuring-bind              :lambda/expr )
( values         values          :prefix         :single
  .x.            values          :unreduce       :single )
( loop           #&lt;FUNCTION identity&gt;            :prefix )
( ||             or              :unreduce
  or             or              :unreduce       :also-prefix )
( &amp;&amp;             and             :unreduce
  and            and             :unreduce       :also-prefix )
( ===            equalp          :single
  equal          equal           :single
  ==             eql             :single
  eql            eql             :single
  eq             eq              :single )
( subtype-of     subtypep )
( :|.|           cons )
( in             member )
( th-cdr         nthcdr )
( =s=            string=         :single
  =c=            char=           :single         :unreduce
  =              =               :single         :unreduce       :also-prefix
  /=             /=              :single         :unreduce       :also-prefix
  &lt;              &lt;               :single         :unreduce       :also-prefix
  &gt;              &gt;               :single         :unreduce       :also-prefix
  &lt;=             &lt;=              :single         :unreduce       :also-prefix
  &gt;=             &gt;=              :single         :unreduce       :also-prefix )
( th-bit         logbitp )
( coerce         coerce )
( !..            nth-value
  th-value       nth-value )
( th             nth )
( .!             elt
  !.             svref
  !!.            row-major-aref )
( .!!.           bit             :rhs-args )
( !!             aref            :rhs-args )
( binfix::~!     gethash         :single         :rhs-args
  !~~            assoc           :single
  ~~!            rassoc          :single )
( .eqv.          bit-eqv         :rhs-args
  .or.           bit-ior         :rhs-args
  .xor.          bit-xor         :rhs-args
  .and.          bit-and         :rhs-args
  .nand.         bit-and         :rhs-args
  .nor.          bit-nor         :rhs-args
  .not.          bit-not         :also-unary
  .orc1.         bit-orc1        :rhs-args
  .orc2.         bit-orc2        :rhs-args
  .andc1.        bit-andc1       :rhs-args
  .andc2.        bit-andc2       :rhs-args )
( dpb            dpb             :rhs-args )
( ldb            ldb )
( ldb-test       ldb-test )
( deposit-field  deposit-field   :rhs-args )
( mask-field     mask-field )
( byte           byte )
( eqv.           logeqv          :also-unary     :unreduce )
( or.            logior          :also-unary     :unreduce )
( xor.           logxor          :also-unary     :unreduce )
( and.           logand          :also-unary     :unreduce )
( nand.          lognand )
( nor.           lognor )
( test.          logtest )
( orc1.          logorc1 )
( orc2.          logorc2 )
( andc1.         logandc1 )
( andc2.         logandc2 )
( &lt;&lt;             ash )
( lcm            lcm             :also-unary     :unreduce )
( gcd            gcd             :also-unary     :unreduce )
( mod            mod )
( rem            rem )
( min            min             :also-prefix    :unreduce       :single
  max            max             :also-prefix    :unreduce       :single )
( +              +               :also-unary     :unreduce )
( -              -               :also-unary     :unreduce )
( /              /               :also-unary )
( *              *               :also-prefix    :unreduce )
( **             expt )
( .!.            bit             :rhs-args )
( !              aref            :rhs-args )
( |;|            |;| )
------------------------------------------------------------------------------
</code></pre>

<p>=> <code>nil</code></p>
