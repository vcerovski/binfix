<p><link href="markdown.css" rel="stylesheet" type="text/css"></link></p>

<h1>BINFIX</h1>

<p>Viktor Cerovski, Mar 2016.</p>

<p><a name="Introduction"></a></p>

<h2>Introduction</h2>

<p>BINFIX (blend from "Binary Infix") is a poweful infix syntax notation for
S-expressions of Common LISP ranging from simple arithmetic and logical
forms to whole programs.</p>

<p>It is in experimental phase with a few important new features still to come.
One of them, available from v0.16, is use of a single <code>;</code> symbol as a
form-separating symbol in <a href="#LET ; progn example">implicit-progn</a>, <a href="#SETF expr-termination">expression
terminator</a> for SETFs, or as end of <a href="#LET ; examples">LET binds
symbol</a> or <a href="#Local functions">local functions definition</a>.</p>

<p>The most recent is <code>def</code>, for <a href="#def">defining things</a>.</p>

<p>Once the rest of them have been implemented, BINFIX will go to RC and then to
reference 1.0 version.</p>

<hr />

<h2>Content</h2>

<ul>
<li><a href="#Instalation">Installation</a></li>
<li><a href="#Examples">Examples</a>
<ul>
<li><a href="#Arithmetic and logical expressions">Arithmetic and logical expressions</a></li>
<li><a href="#Consing">Consing</a></li>
<li><a href="#Lambdas, definitions and type annotations">Lambdas, definitions and type annotations</a>
<ul>
<li><a href="#lambda">lambda</a></li>
<li><a href="#defun">defun</a></li>
<li><a href="#&amp;optional">&amp;optional</a></li>
<li><a href="#Local functions">Local functions</a></li>
<li><a href="#defmethod">defmethod</a></li>
<li><a href="#defmacro">defmacro</a></li>
<li><a href="#def">def</a></li>
<li><a href="#types">Type annotations, declarations and definitions</a></li>
</ul></li>
<li><a href="#LETs">LETs</a></li>
<li><a href="#SETs">SETs</a></li>
<li><a href="#Implicit progn">Implicit <code>progn</code></a></li>
<li><a href="#<code>$</code>plitter"><code>$</code>plitter</a></li>
<li><a href="#Multiple-choice forms">Multiple-choice forms</a></li>
<li><a href="#Destructuring, multiple values">Destructuring, multiple values</a></li>
<li><a href="#Loops">Loops</a></li>
</ul></li>
<li><a href="#Support for macros">Support for macros</a></li>
<li><a href="#More involved examples">More involved examples</a>
<ul>
<li><a href="#ordinal">ordinal</a></li>
<li><a href="#join">join</a></li>
<li><a href="#values-bind">values-bind</a></li>
<li><a href="#for">for</a></li>
</ul></li>
<li><a href="#Implementation">Implementation</a>
<ul>
<li><a href="#proto-BINFIX">proto-BINFIX</a></li>
</ul></li>
<li><a href="#Appendix">Appendix</a>
<ul>
<li><a href="#Operation properties">Operation properties</a></li>
<li><a href="#List of all operations">List of all operations</a></li>
</ul></li>
</ul>

<hr />

<p><a name="Instalation"></a></p>

<h2>Instalation</h2>

<p><a href="https://www.quicklisp.org/">Quicklisp</a> makes the
downloading/installation/loading trivial:</p>

<pre><code>(ql:quickload :binfix)
</code></pre>

<p>After loading the package, the next step is to allow use of its symbols</p>

<pre><code>(use-package :binfix)
</code></pre>

<p>BINFIX is developed using
<a href="https://en.wikipedia.org/wiki/Steel_Bank_Common_Lisp">SBCL</a>, and checked to
work fine with <a href="https://en.wikipedia.org/wiki/CLISP">CLISP</a>,
and <a href="https://en.wikipedia.org/wiki/Clozure_CL">Clozure CL</a>,
while with <a href="https://en.wikipedia.org/wiki/Embeddable_Common_Lisp">ECL</a> there
have been some problems with loading and testing recently, so for the
time being BINFIX is not running on ECL.
<!-- passes tests when hand-loaded but does not go through the package system yet. --></p>

<p>BINFIX shadows <code>!</code> in CLISP (<code>ext:!</code>), <code>@</code> in Clozure CL and ECL, as well as
<code>var</code> (<code>sb-debug:var</code>) in SBCL.</p>

<p>The latest version is available at <a href="https://github.com/vcerovski/binfix">gihub</a>,
and can be obtained by</p>

<pre><code>git clone https://github.com/vcerovski/binfix
</code></pre>

<p><a name="Examples"></a></p>

<h2>Examples</h2>

<p>Generally, quoting a BINFIX expression in REPL will produce the corresponding
S-expression.</p>

<p>For easier comparison of input and output forms in following examples, LISP
printer is first <code>setq</code> (operation <code>=.</code>) to lowercase output with</p>

<pre><code>{*print-case* =. :downcase}
</code></pre>

<p>=> <code>:downcase</code></p>

<p>BINFIX is a free-form notation (just like S-expr), i.e any number of empty
spaces (including tabs and newlines) between tokens is treated the same as a
single white space.</p>

<p><a name="Arithmetic and logical expressions"></a></p>

<h3>Arithmetic and logical expressions</h3>

<p>Classic math stuff:</p>

<pre><code>{2 * 3 + 4}
</code></pre>

<p>=> <code>10</code></p>

<pre><code>'{a * {b + c}}
</code></pre>

<p>=> <code>(* a (+ b c))</code></p>

<pre><code>'{- {x + y} / x * y}
</code></pre>

<p>=> <code>(- (/ (+ x y) (* x y)))</code></p>

<pre><code>'{0 &lt; x &lt; 1 &amp;&amp; y &gt;= 1 || y &gt;= 2}
</code></pre>

<p>=> <code>(or (and (&lt; 0 x 1) (&gt;= y 1)) (&gt;= y 2))</code></p>

<pre><code>'{- f x - g x - h x}
</code></pre>

<p>=> <code>(- (- (f x)) (g x) (h x))</code></p>

<p>Expressions like <code>{(f x y) * (g a b)}</code> and <code>{{f x y} * {g a b}}</code> generally
produce the same result. The inner brackets, however, can be removed:</p>

<pre><code>'{sqrt x * sin x}
</code></pre>

<p>=> <code>(* (sqrt x) (sin x))</code></p>

<pre><code>'{A ! i .= B ! j + C ! k}
</code></pre>

<p>=> <code>(setf (aref a i) (+ (aref b j) (aref c k)))</code></p>

<pre><code>'{a ! i j += b ! i k * c ! k j}
</code></pre>

<p>=> <code>(incf (aref a i j) (* (aref b i k) (aref c k j)))</code></p>

<pre><code>'{listp A &amp;&amp; car A == 'x &amp;&amp; cdr A || A}
</code></pre>

<p>=> <code>(or (and (listp a) (eql (car a) 'x) (cdr x)) a)</code></p>

<p><a name="Consing"></a></p>

<h3>Consing</h3>

<p>Operation <code>:.</code> stands for <code>cons</code>. For instance,</p>

<pre><code>{-2 :. loop for i to 9 collect i}
</code></pre>

<p>=> <code>(-2 0 1 2 3 4 5 6 7 8 9)</code></p>

<p>with the familiar behaviour:</p>

<pre><code>{{1 :. 2 :. 3} equal '(1 2 . 3)}
</code></pre>

<p>=> <code>t</code></p>

<pre><code>{{1 :. 2 :. 3 :. {}} equal '(1 2 3)}
</code></pre>

<p>=> <code>t</code></p>

<p><a name="Lambdas, definitions and type annotations"></a></p>

<h3>Lambdas, definitions and type annotations</h3>

<p><a name="lambda"></a></p>

<h4><code>lambda</code></h4>

<pre><code>'{x -&gt; sqrt x * sin x}
</code></pre>

<p>=> <code>(lambda (x) (* (sqrt x) (sin x)))</code></p>

<pre><code>'{x :single-float -&gt; sqrt x * sin x}
</code></pre>

<p>=> <code>(lambda (x) (declare (type single-float x)) (* (sqrt x) (sin x)))</code></p>

<pre><code>'{x y -&gt; {x - y}/{x + y}}
</code></pre>

<p>=> <code>(lambda (x y) (/ (- x y) (+ x y)))</code></p>

<p>Mixing of notations works as well, so each of the following</p>

<pre><code>{x y -&gt; / (- x y) (+ x y)}
{x y -&gt; (- x y)/(+ x y)}
{x y -&gt; (/ (- x y) (+ x y))}
</code></pre>

<p>produces the same form.</p>

<p>Fancy way of writing <code>{2 * 3 + 4}</code></p>

<pre><code>{x -&gt; y -&gt; z -&gt; x * y + z @ 2 @ 3 @ 4}
</code></pre>

<p>=> <code>10</code></p>

<p>Quoting reveals the expanded S-expr</p>

<pre><code>'{x -&gt; y -&gt; z -&gt; x * y + z @ 2 @ 3 @ 4}
</code></pre>

<p>=></p>

<pre><code>(funcall (funcall (funcall
  (lambda (x) (lambda (y) (lambda (z) (+ (* x y) z))))
    2) 3) 4)
</code></pre>

<p>Indeed, <code>@</code> is left-associative, standing for <code>funcall</code>.</p>

<p>More complicated types can be also explicitely given after an
argument, </p>

<pre><code>'{x :|or symbol number| -&gt; x :. x}
</code></pre>

<p>=></p>

<pre><code>(lambda (x) (declare (type (or symbol number) x)) (cons x x))
</code></pre>

<p>Mapping is also supported:</p>

<pre><code>'{x -&gt; sin x * sqrt x @. (f x)}
</code></pre>

<p>=></p>

<pre><code>(mapcar (lambda (x) (* (sin x) (sqrt x))) (f x))
</code></pre>

<p>Alternatively, it is possible to use the expression-termination symbol <code>;</code>,</p>

<pre><code>{x -&gt; sin x * sqrt x @. f x;}
</code></pre>

<p>to the same effect.</p>

<p><a name="defun"></a></p>

<h4><code>defun</code></h4>

<p>Factorial fun:</p>

<pre><code>'{f n :integer := if {n &lt;= 0} 1 {n * f {1- n}}}
</code></pre>

<p>=></p>

<pre><code>(defun f (n)
  (declare (type integer n))
  (if (&lt;= n 0)
      1
      (* n (f (1- n)))))
</code></pre>

<p>Function documentation, local declarations, local bindings 
and comments have a straightforward syntax:</p>

<pre><code>'{g x := "Auxilary fn."
   declare (inline)
   let x*x = x * x; ;; Note binds termination via ;
     x*x / 1+ x*x}
</code></pre>

<p>=></p>

<pre><code>(defun g (x)
  "Auxilary fn."
  (declare (inline))
  (let ((x*x (* x x)))
    (/ x*x (1+ x*x))))
</code></pre>

<p><a name="&amp;optional"></a></p>

<h4><code>&amp;optional</code> is optional</h4>

<p>Explicitely tail-recursive version of <code>f</code></p>

<pre><code>'{fac n m = 1 :=
   declare (integer m n)
   if {n &lt;= 0} m
      {fac {n - 1} {n * m}}}
</code></pre>

<p>=></p>

<pre><code>(defun fac (n &amp;optional (m 1))
  (declare (integer m n))
  (if (&lt;= n 0)
      m
      (fac (- n 1) (* n m))))
</code></pre>

<p>As you may by now expect, the following is also permited</p>

<pre><code>{fac n :integer m :integer = 1 :=
  if {n &lt;= 0} m
     {fac {n - 1} {n * m}}}
</code></pre>

<p><a name="Local functions"></a></p>

<h4>Local functions</h4>

<p>Version of <code>fac</code> with a local recursive function <code>f</code>:</p>

<pre><code>{fac n :integer :=
  labels
    f n m := {if {n = 0} m
                 {f (1- n) {n * m}}}
   f n 1}
</code></pre>

<p>Another syntax to specify a local function is to use a single <code>;</code> as in</p>

<pre><code>{fac n :integer :=
  labels
    f n m := if {n = 0} m
                {f (1- n) {n * m}};
   f n 1}
</code></pre>

<!--
There is also yet another way to write the definition of `fac`, as

    {fac n :integer :=
      labels
        f n m := {if n = 0; m; f (1- n) {n * m}}
       f n 1}
-->

<p>All three above definitions of <code>fac</code> are transformed by <code>binfix</code> to</p>

<pre><code>(defun fac (n)
  (declare (type integer n))
  (labels ((f (n m)
             (if (= n 0)
                 m
                 (f (1- n) (* n m)))))
</code></pre>

<p>which can be demonstrated by simply evaluating the quoted expressions.</p>

<p>The same syntax is used also in the case of <code>flet</code> and <code>macrolet</code>.</p>

<p><a name="defmethod"></a></p>

<h4><code>defmethod</code></h4>

<p>The following generic versions of <code>f</code></p>

<pre><code>'{f n :integer :- if {n &lt;= 0} 1 {n * f {1- n}}}
'{f (n integer):- if {n &lt;= 0} 1 {n * f {1- n}}}
</code></pre>

<!--
    '{f n :integer :- {if n <= 0; 1;
                          n * f(1- n)}}
-->

<p>all produce</p>

<pre><code>(defmethod f ((n integer))
  (if (&lt;= n 0)
      1
      (* n (f (1- n)))))
</code></pre>

<p><code>:-</code> supports also eql-specialization via <code>==</code> op, analogous to
the way <code>=</code> is used for optional arguments initialization, as well as an
optional method qualifier, given as the first argument after the method name,
that can be either a keyword or an atom surrounded by parens (i.e <code>:around</code>,
<code>(reduce)</code> etc.)</p>

<p><a name="defmacro"></a></p>

<h4><code>defmacro</code></h4>

<p>Macros are defined via <code>:==</code> operation, similar to the previous examples.
See Sec. <a href="#Support for macros">Support for macros</a>.</p>

<p><a name="types"></a></p>

<h4>Type annotations, declarations and definitions</h4>

<p>The examples shown so far demonstrate the possibility to type-annotate
symbols in binds and lambda-lists by an (optional) keyword representing
the type (for instance <code>:fixnum</code>, <code>:my-class</code>, <code>:|simple-array single-float|</code>,
<code>:|or symbol number|</code>, <code>:|{symbol or number}|</code>, etc.)</p>

<p>OPs that represent LISP forms which allow declaration(s), in BINFIX can 
have in addition to the standard <code>(declare ...)</code> form also unparenthesized
variant:</p>

<pre><code>'{f x :fixnum y = 2 :=
   declare (inline)
   declare (fixnum y)
   x + y ** 2}
</code></pre>

<p>=></p>

<pre><code>(defun f (x &amp;optional (y 2))
  (declare (type fixnum x))
  (declare (inline))
  (declare (fixnum y))
  (+ x (expt y 2)))
</code></pre>

<p>Operation <code>:-&gt;</code> can be used to specify function type. For example, in
SBCL 1.1.17 function <code>sin</code> has declared type that can be written as</p>

<pre><code>'{number :-&gt; single-float -1.0 1.0 ||
             double-float -1.0 1.0 ||
             complex single-float  ||
             complex double-float .x. &amp;optional}
</code></pre>

<p>=></p>

<pre><code>(function (number)
 (values
  (or (single-float -1.0 1.0)
      (double-float -1.0 1.0)
      (complex single-float)
      (complex double-float))
  &amp;optional))
</code></pre>

<p>Type definitions are given using <code>:type=</code> OP, as in</p>

<pre><code>`{mod n :type= `(integer 0 (,n))}
</code></pre>

<p>=></p>

<pre><code>(deftype mod (n) `(integer 0 (,n)))
</code></pre>

<p><a name="def"></a></p>

<h4><code>def</code></h4>

<p>Program typically consists of a number of definitions of functions,
constants, parameters, types, etc. The operation <code>def</code> is introduced
to facilitate their easy writing:</p>

<pre><code>'{def parameter *x* = 1 *y* = 2
  def struct point x y z
  def f x := sqrt x * sin x}
</code></pre>

<p>=></p>

<pre><code>(progn
 nil
 (defparameter *x* 1)
 (defparameter *y* 2)
 (defstruct point x y z)
 (defun f (x) (* (sqrt x) (sin x))))
</code></pre>

<p>As it is clear from the example, the definitions are wrapped up in <code>progn</code>.</p>

<p>More detailed definitions are also straightforward to specify:</p>

<pre><code>'{def parameter
    *x* :fixnum = 1
    *y* :fixnum = 2;

  struct point "Point"
    :print-function {p s d -&gt;
                       declare (ignore d)
                       with-slots (x y z) p
                         (format s "#&lt;~$ ~$ ~$&gt;" x y z)}
    x :single-float = 0f0
    y :single-float = 0f0
    z :single-float = 0f0

  def f x :single-float :=
    declare (inline)
    sqrt x * sin x}
</code></pre>

<p>=></p>

<pre><code>(progn
 nil
 (declaim (type fixnum *x*)
          (type fixnum *y*))
 (defparameter *x* 1)
 (defparameter *y* 2)
 (defstruct
     (point
      (:print-function
       (lambda (s p d)
         (declare (ignore d))
         (with-slots (x y z)
             p
           (format s "#&lt;~$ ~$ ~$&gt;" x y z)))))
   "Point"
   (x 0.0 :type single-float)
   (y 0.0 :type single-float)
   (z 0.0 :type single-float))
 (defun f (x)
   (declare (type single-float x)
            (inline))
   (* (sqrt x) (sin x))))
</code></pre>

<p><code>def</code>ining of symbols follows the same syntax as <code>let</code> binding, which
is covered next.</p>

<p><a name="LETs"></a></p>

<h3>LETs</h3>

<p>LET symbol-binding forms (<code>let</code>, <code>let*</code> and <code>symbol-macrolet</code>) in BINFIX use
<code>=</code>  with an optional type-annotation:</p>

<pre><code>'{let x :bit = 1
      y = {2 ** 3}
      z = 4
    x + y * z}
</code></pre>

<p>=></p>

<pre><code>(let ((x 1) (y (expt 2 3)) (z 4))
  (declare (type bit x))
  (+ x (* y z)))
</code></pre>

<p><a name="LET ; examples"></a>
A single <code>;</code> can be used as a terminator of bindings:</p>

<pre><code>'{let x :bit = 1
      y = 2 ** 3
      z = f a;
    x + y * z}
</code></pre>

<p>=></p>

<pre><code>(let ((x 1) (y (expt 2 3)) (z (f a)))
  (declare (type bit x))
  (+ x (* y z)))
</code></pre>

<p><a name="LET ; progn example"></a>
Finally, a single <code>;</code> can also be used to separate forms in implicit-progn,
as in</p>

<pre><code>'{let x :bit = 1
      y = 2 ** 3
      z = f a;         ;; end of binds
    print "Let binds"; ;; 1st form
    x + y * z}         ;; 2nd form of implicit-progn
</code></pre>

<p>=></p>

<pre><code>(let ((x 1) (y (expt 2 3)) (z (f a)))
  (declare (type bit x))
  (print "Let binds")
  (+ x (* y z)))
</code></pre>

<p><a name="LET associativity"></a>
Nesting of <code>let</code>s without parens follows the right-associativity</p>

<pre><code>'{let a = f x;
    if a
      (g x)
      let b = h x;
        f b}
</code></pre>

<p>=></p>

<pre><code>(let ((a (f x)))
  (if a
      (g x)
      (let ((b (h x)))
        (f b))))
</code></pre>

<p>Note the three levels of parens gone.</p>

<p><a name="SETs"></a></p>

<h3>SETs</h3>

<p>In addition to <code>=.</code> and <code>.=</code> OPs representing, respectively, a single <code>setq</code>
and <code>setf</code> assignment, multiple assignments via SETs can be done using <code>=</code>,</p>

<pre><code>'{psetq x =   cos a * x + sin a * y
        y = - sin a * x + cos a * y}
</code></pre>

<p>=></p>

<pre><code>(psetq x (+ (* (cos a) x) (* (sin a) y))
       y (+ (- (* (sin a) x)) (* (cos a) y)))
</code></pre>

<p>and in the case of SETF assignments, RHS are represented with a single
expression,</p>

<pre><code>'{psetf a ! 0 = {a ! 1}
        a ! 1 = {a ! 0}}
</code></pre>

<p>=></p>

<pre><code>(psetf (aref a 0) (aref a 1)
       (aref a 1) (aref a 0))
</code></pre>

<p><a name="SETF expr-termination"></a>
Alternatively, it is possible to use a single <code>;</code> as an expression-termination
symbol,</p>

<pre><code>'{psetf a ! 0 = a ! 1; ;; expr. termination via single ;
        a ! 1 = a ! 0}
</code></pre>

<p>=></p>

<pre><code>(psetf (aref a 0) (aref a 1)
       (aref a 1) (aref a 0))
</code></pre>

<p>It is also possible to mix infix SETFs with other expressions:</p>

<pre><code>'{f x + setf a = b
             c = d;
      * h a c}
</code></pre>

<p>=></p>

<pre><code>(+ (f x)
   (*
    (setf a b
          c d)
    (h a c)))
</code></pre>

<p><a name="Implicit progn"></a></p>

<h3>Implicit <code>progn</code></h3>

<p>An implicit <code>progn</code> in BINFIX is achieved with a single <code>;</code> separating the
forms forming the progn.  In all cases (<code>-&gt;</code>, <code>:=</code>, <code>:-</code> and LETs) the syntax
is following that of the <a href="#LET ; progn example">LET example above</a>.</p>

<p>As expected, other <code>prog</code>s have to be explicitly given,</p>

<pre><code>'{x -&gt; prog2 (format t "Calculating... ")
             {f $ x * x}
             (format t "done.~%")}
</code></pre>

<p>or</p>

<pre><code>'{x -&gt; prog2
         format t "Calculating... ";
         f {x * x};
         format t "done.~%"}
</code></pre>

<p>both producing the following form</p>

<pre><code>(lambda (x)
  (prog2 (format t "Calculating... ") (f (* x x)) (format t "done.~%")))
</code></pre>

<p>Since BINFIX is a free-form notation, the following one-liner also works:</p>

<pre><code>'{x -&gt; prog2 format t "Calculating... "; f{x * x}; format t "done.~%"}
</code></pre>

<p>Binfix <code>&lt;&amp;</code> stands for <code>prog1</code>,</p>

<pre><code>'{x -&gt; {f {x * x} &lt;&amp;
        format t "Calculation done.~%"}}
</code></pre>

<p>=></p>

<pre><code>(lambda (x) (prog1 (f (* x x)) (format t "Calculation done.~%")))
</code></pre>

<p><a name="<code>$</code>plitter"></a></p>

<h3><code>$</code>plitter</h3>

<p>Infix <code>$</code> is a vanishing OP, leaving only its arguments,
effectivelly splitting the list in two parts.</p>

<pre><code>'{f $ g $ h x y z}
</code></pre>

<p>=> <code>(f (g (h x y z)))</code></p>

<p>So its effect here is similar to <code>$</code> in Haskell. 
Or perphaps:</p>

<pre><code>'{declare $ optimize (speed 1) (safety 1)}
</code></pre>

<p>=> <code>(declare (optimize (speed 1) (safety 1)))</code></p>

<p><code>$</code>plitter also allows writing a shorter <code>cond</code>, as in</p>

<pre><code>(cond {p x $ f x}
      {q x $ g x}
      {r x $ h x}
      {t $ x})
</code></pre>

<p>compared to the equivalent</p>

<pre><code>(cond ((p x) (f x))
      ((q x) (g x))
      ((r x) (h x))
      (t x))
</code></pre>

<p>Another splitter is <code>?</code>, which can be used instead of <code>$</code> in the previous
example, as well as described in the next section.</p>

<p><a name="Multiple-choice forms"></a></p>

<h3>Multiple-choice forms (<code>cond</code>, <code>case</code>, ...)</h3>

<p>An alternative syntax to describe multiple-choice forms is to use <code>?</code> and <code>;</code></p>

<pre><code>{cond p x ? f x;
      q x ? g x;
      r x ? h x;
        t ? x}
</code></pre>

<p>See also <a href="#ordinal"><code>ordinal</code> example below</a>.</p>

<p><a name="Destructuring, multiple values"></a></p>

<h3>Destructuring, multiple values</h3>

<p>Multiple values (<code>values</code>) are represented by <code>.x.</code>, 
<code>multiple-value-bind</code> by <code>=..</code> , and <code>destructuring-bind</code> by <code>..=</code></p>

<pre><code>'{a (b) c ..= (f x) a + 1 .x. b + 2 .x. c + 3}
</code></pre>

<p>=></p>

<pre><code>(destructuring-bind (a (b) c) (f x) (values (+ a 1) (+ b 2) (+ c 3)))
</code></pre>

<p>Another way to write the same expr:</p>

<pre><code>'{a (b) c ..= (f x) values a + 1; b + 2; c + 3}
</code></pre>

<p><code>multiple-value-call</code> is represented by <code>.@.</code></p>

<pre><code>'{#'list .@. 1 '(b 2) 3}
</code></pre>

<p>=></p>

<pre><code>(multiple-value-call #'list 1 '(b 2) 3)
</code></pre>

<p>=></p>

<pre><code>(1 (b 2) 3)
</code></pre>

<p><a name="Loops"></a></p>

<h4>Loops</h4>

<p>Loops can be also nested without writing parens:</p>

<pre><code>'{loop for i = 1 to 3
       collect loop for j = 2 to 4
                    collect {i :. j}}
</code></pre>

<p>=></p>

<pre><code>(loop for i = 1 to 3
      collect (loop for j = 2 to 4
                    collect (cons i j)))
</code></pre>

<p><a name="Support for macros"></a></p>

<h3>Support for macros</h3>

<p>If BINFIX terms <em>only</em> are inserted under backquote, everything should work
fine, </p>

<pre><code>'{let t1 = 'x
      t2 = '{x + x}
     `{x -&gt; ,t1 / ,t2}}
</code></pre>

<p>=></p>

<pre><code>(let ((t1 'x) (t2 '(+ x x)))
  `(lambda (x) (/ ,t1 ,t2)))
</code></pre>

<p>Replacing, however, BINFIX operations inside a backquoted BINFIX will <em>not</em>
work.  This is currently not considered as a problem because direct call of
<code>binfix</code> will cover some important cases of macro transformations in a 
straightforward manner:</p>

<pre><code>{m x y :==
   let a = (gensym)
       b = (gensym)
     binfix `(let ,a :double-float = ,x
                  ,b :double-float = ,y
                {,a - ,b} / {,a + ,b})}
</code></pre>

<p>Now macro <code>m</code> works as expected:</p>

<pre><code>(macroexpand-1 '(m (f x y) {a + b}))
</code></pre>

<p>=></p>

<pre><code>(let ((#:g805 (f x y)) (#:g806 (+ a b)))
  (declare (type double-float #:g806)
           (type double-float #:g805))
  (/ (- #:g805 #:g806) (+ #:g805 #:g806)))
t
</code></pre>

<p>See more in <a href="#binfix macros">implementation details</a></p>

<p><a name="More involved examples"></a></p>

<h3>More involved examples</h3>

<p><a name="ordinal"></a></p>

<h4><code>ordinal</code></h4>

<p>Converting an integer into ordinal string in English can be defined as</p>

<pre><code>{ordinal i :integer :=
   let* a = i mod 10
        b = i mod 100
      suf = {cond
               a = b = 1 || a = 1 &amp;&amp; 21 &lt;= b &lt;= 91 ? "st";
               a = b = 2 || a = 2 &amp;&amp; 22 &lt;= b &lt;= 92 ? "nd";
               a = b = 3 || a = 3 &amp;&amp; 23 &lt;= b &lt;= 93 ? "rd";
                                                t  ? "th"}
        format () "~D~a" i suf}
</code></pre>

<p>It can be also written in a more "lispy" way without parens as</p>

<pre><code>{ordinal1 i :integer :=
   let* a = i mod 10
        b = i mod 100
      suf = {cond
               = a b 1 or = a 1 and &lt;= b 21 91 ? "st";
               = a b 2 or = a 2 and &lt;= b 22 92 ? "nd";
               = a b 3 or = a 3 and &lt;= b 23 93 ? "rd";
                                            t  ? "th"}
        format () "~D~a" i suf}
</code></pre>

<p>which can be tried using <code>@.</code> (<code>mapcar</code>)</p>

<pre><code>{#'ordinal @. '(0 1 12 22 43 57 1901)}
</code></pre>

<p>=> <code>("0th" "1st" "12th" "22nd" "43rd" "57th" "1901st")</code></p>

<p>(This example is picked up from <a href="http://blog.rust-lang.org/2015/04/17/Enums-match-mutation-and-moves.html">Rust
blog</a>)</p>

<p><a name="join"></a></p>

<h4><code>join</code></h4>

<p>APL-ish joining of things into list:</p>

<pre><code>{
  defgeneric join (a b) &amp;

  join a :list  b :list :- append a b        &amp;
  join a :t     b :list :- cons a b          &amp;
  join a :list  b :t    :- append a (list b) &amp;
  join a :t     b :t    :- list a b          &amp;

  defbinfix '++ 'join 
}
; Must close here in order to use ++

{let e = '{2 in 'x ++ '(1 2 3) ++ '((a)) ++ -1 * 2}
    format t "~S~%=&gt; ~S" e (eval e)}
</code></pre>

<p>Evaluation of the above returns <code>t</code> and prints the following</p>

<pre><code>(member 2 (join 'x (join '(1 2 3) (join '((a)) (* -1 2)))))
=&gt; (2 3 (a) -2)
</code></pre>

<p><a name="values-bind"></a></p>

<h4><code>values-bind</code></h4>

<p>Macro <code>multiple-value-bind</code> with symbol <code>_</code> in variable list standing for
an ignored value can be defined as</p>

<pre><code>{values-bind v e &amp;rest r :==
  let*  _ = ()
     vars = a -&gt; if {a == '_} {car $ push (gensym) _} a @. v;
    `(multiple-value-bind ,vars ,e
        ,@{_ &amp;&amp; `({declare $ ignore ,@_})}
        ,@r)}
</code></pre>

<p>So, for instance,</p>

<pre><code>(macroexpand-1 '(values-bind (a _) (truncate 10 3) a))
</code></pre>

<p>=></p>

<pre><code>(multiple-value-bind (a #:g823) (truncate 10 3) (declare (ignore #:g823)) a)
t
</code></pre>

<p><a name="for"></a></p>

<h4><code>for</code></h4>

<p>Nested BINFIX lambda lists can be used in definitions of macros, as in the
following example of a procedural for-loop macro</p>

<pre><code>{for (v :symbol from below by = 1) &amp;rest r :==
  `(loop for,v fixnum from,from below,below ,@{by /= 1 &amp;&amp; `(by,by)}
         do ,@r)}
</code></pre>

<p>Now</p>

<pre><code>(macroexpand-1 '(for (i 0 n)
                  {a ! i .= 1+ i}))
</code></pre>

<p>=></p>

<pre><code>(loop for i fixnum from 0 below n
      do (setf (aref a i) (1+ i)))
t
</code></pre>

<p><a name="Implementation"></a></p>

<h2>Implementation</h2>

<p>BINFIX expression is written as a list enclosed in curly brackets <code>{</code> ... <code>}</code>
handled through LISP reader, so the usual syntax rules of LISP apply, e.g <code>a+b</code>
is a single symbol, while <code>a + b</code> is three symbols.  Lisp reader after
tokenization calls the function <code>binfix</code> which does shallow transformation of
BINFIX into S-expr representation of the expression.</p>

<p>BINFIX uses a simple rewrite algorithm that divides a list in two, LHS and RHS
of the lowest priority infix operator found within the list, then recursively
processes each one.</p>

<p><a name="proto-BINFIX"></a></p>

<h3>proto-BINFIX</h3>

<p>Bootstraping is done beginning with proto-BINFIX,</p>

<pre><code>(defparameter *binfix*
  '(( &amp;  progn)
    (:== def defmacro)
    (:=  def defun)
    (:-  def defmethod)
    ( =. setq)
    (.=  setf)
    (-&gt;  def lambda)
    ($)
    (labels flet= labels)
    (let  let= let)
    (let* let= let*)
    (:.   cons)
    (||   or)
    (&amp;&amp;   and)
    (==   eql)
    (=c=  char=)
    (in   member)
    ( !   aref)))

(defun binfix (e &amp;optional (ops *binfix*))
  (cond ((atom e) e)
        ((null ops) (if (cdr e) e (car e)))
        (t (let* ((op (car ops))
                  (i (position (pop op) e)))
             (if (null i)
               (binfix e (cdr ops))
              `(,@op
                ,(if (eql (car op) 'def)
                    (subseq e 0 i)
                    (binfix (subseq e 0 i) (cdr ops)))
                ,(binfix (subseq e (1+ i)) ops)))))))

(set-macro-character #\{
  (lambda (s ch) (declare (ignore ch))
    (binfix (read-delimited-list #\} s t))))

(set-macro-character #\} (get-macro-character #\) ))
</code></pre>

<p>which captures the basics of BINFIX.</p>

<p>The next bootstrap phase defines macro <code>def</code> and, in the same 
single BINFIX expression, macros <code>let=</code> and <code>flet=</code></p>

<pre><code>{defmacro def (what args body)
  `(,what ,@(if {what == 'lambda}
              `(,(if {args &amp;&amp; atom args} `(,args) args))
               (if (atom args) `(,args ()) `(,(car args),(cdr args))))
          ,body) &amp;

 let= let lhs body &amp;aux vars :==
  loop while {cadr body == '=}
     do {push `(,(car body),(caddr body)) vars &amp;
         body =. cdddr body}
     finally (return (let ((let `(,let ,(nreverse vars) ,@body)))
                       (if lhs `(,@lhs ,let) let))) &amp;

 flet= flet lhs body &amp;aux funs :==
  loop for r = {'= in body} while r
       for (name . lambda) = (ldiff body r)
       do {push `(,name ,lambda ,(cadr r)) funs &amp;
           body =. cddr r}
       finally (return (let ((flet `(,flet ,(nreverse funs) ,@body)))
                         (if lhs `(,@lhs ,flet) flet)))}
</code></pre>

<p>which wraps up proto-BINFIX.</p>

<p>Since v0.15, BINFIX interns a symbol consisting of a single <code>;</code> char not
followed by <code>;</code> char, while two or more consequtive <code>;</code> are interpreted
as starting a comment.  This behavior is limited to BINFIX
expressions only, while outside of them the standard LISP rules apply.</p>

<p>Since v0.19, proto-BINFIX introduces <code>unreduc</code> property.</p>

<p>The rest is written using this syntax, and consists of handling of lambda lists
and <code>let</code>s, a longer list of OPs with properties, redefined <code>binfix</code> to
its full capability, and, finally, several interface functions for
dealing with OPs (<code>lsbinfix</code>, <code>defbinfix</code> and <code>rmbinfix</code>).</p>

<p>Priorities of operations are given only relatively, with no numerical values and
thus with no two operations of the same priority.</p>

<p><a name="binfix macros"></a>
Since shallow transformation into standard syntax is done by function <code>binfix</code>
invoked recursively by the reader, <code>binfix</code> cannot be directly called for
arbitrary macro transformation of BINFIX into BINFIX when standard macro
helpers BACKTICK, COMA and COMA-AT are used. The reason is that <code>{</code>...<code>}</code> is
invoked before them while the correct order would be after them.
Examples of succesful combinations of backquoting and BINFIX are given
<a href="#Support for macros">above</a>.</p>

<p><a name="Appendix"></a></p>

<h2>Appendix</h2>

<p><a name="Operation properties"></a></p>

<h3>Operation properties</h3>

<p><code>:def</code> -- Operation (OP) is a definition requiring LHS to has a name and lambda
list.</p>

<p><code>:defm</code> -- OP is a definition requiring LHS to have a name followed by
unparenthesized method lambda list.</p>

<p><code>:lhs-lambda</code> -- OP has lambda list as its LHS.</p>

<p><code>:rhs-lbinds</code> -- OP has let-binds at the beginning of its LHS,<br>
[<em>symbol</em> [<em>keyword</em>] <strong><code>=</code></strong> <em>expr</em>]* <em>declaration</em>*</p>

<p><code>:rhs-fbinds</code> -- OP has flet-binds at the beginning of its LHS, including
optional declarations.</p>

<p><code>:rhs-sbinds</code> -- OP has symbol-binds as its RHS. They are let-binds without
annotations or declarations,
[<em>symbol</em> <strong><code>=</code></strong> <em>expr</em><sup>+</sup>]<sup>+</sup></p>

<p><code>:rhs-ebinds</code> -- OP has expr-binds at the beginning of its RHS,
[<em>expr</em><sup>+</sup> <strong><code>=</code></strong> <em>expr</em>]*</p>

<p><code>:unreduce</code> -- All appearances of OP at the current level should be unreduced,
i.e replaced with a single call with multiple arguments.</p>

<p><code>:left-assoc</code> -- OP is left--associative (OPs are right-associative by default.)</p>

<p><code>:prefix</code> -- OP is prefix with RHS being its arguments, given as one or more
atoms/S-expr or a single <code>;</code> separated B-expr.</p>

<p><code>:also-prefix</code> -- OP can be used as prefix when LHS is missing.</p>

<p><code>:also-unary</code> -- OP can be used as unary when LHS is missing.</p>

<p><code>:also-postfix</code> -- OP can be used as postfix when RHS is missing.</p>

<p><code>:lambda/expr</code> -- OP takes lambda-list at LHS and an expression at RHS, followed by body.</p>

<p><code>:syms/expr</code> -- OP takes a list of symbols as LHS (each with an optional
<a href="#types">keyword-type</a> annotation,) an expression as RHS followed
by optional declarations and a BINFIX-expression.</p>

<p><code>#'my-fun</code> -- function <code>my-fun</code> will be applied to the untransformed RHS.</p>

<p><code>:split</code> -- OP splits the expr at this point.</p>

<p><code>:rhs-args</code> -- OP takes LHS as 1st and RHS as remaining arguments.</p>

<p><code>:macro</code> -- OP is a macro.</p>

<p><a name="List of all operations"></a></p>

<h3>List of all operations</h3>

<pre><code>(lsbinfix)
</code></pre>

<p>prints the table of all BINFIX OPs and their properties from the weakest-
to the strongest-binding OP:</p>

<pre><code>BINFIX           LISP            Properties
============================================================
&lt;&amp;               prog1           
&amp;                progn           :unreduce       
def              binfix::defs    :macro          
let              let             :rhs-lbinds     
let*             let*            :rhs-lbinds     
symbol-macrolet  symbol-macrolet :rhs-lbinds     
prog*            prog*           :rhs-lbinds     
prog             prog            :rhs-lbinds     
macrolet         macrolet        :rhs-fbinds     
flet             flet            :rhs-fbinds     
labels           labels          :rhs-fbinds     
:==              defmacro        :def            
:=               defun           :def            
:-               defmethod       :defm           
:type=           deftype         :def            
block            block           :prefix         
tagbody          tagbody         :prefix         
catch            catch           :prefix         
prog2            prog2           :prefix         
progn            progn           :prefix         
cond             cond            :prefix         
case             case            :prefix         
ccase            ccase           :prefix         
ecase            ecase           :prefix         
typecase         typecase        :prefix         
etypecase        etypecase       :prefix         
ctypecase        ctypecase       :prefix         
loop             #&lt;FUNCTION identity&gt;            :prefix         
?                nil             :split          
$                nil             :split          
.=               setf            
+=               incf            
-=               decf            
=.               setq            
.=.              set             
setq             setq            :rhs-sbinds     
set              set             :rhs-sbinds     
psetq            psetq           :rhs-sbinds     
setf             setf            :rhs-ebinds     
psetf            psetf           :rhs-ebinds     
.@               mapc            :rhs-args       
..@              mapl            :rhs-args       
@/               reduce          :rhs-args       
@.               mapcar          :rhs-args       
@..              maplist         :rhs-args       
@n               mapcan          :rhs-args       
@.n              mapcon          :rhs-args       
@@               apply           :rhs-args       
@                funcall         :rhs-args       :left-assoc     :also-postfix   
:-&gt;              function        :lhs-lambda     
-&gt;               lambda          :lhs-lambda     
values           values          :prefix         
=..              multiple-value-bind             :syms/expr      
.@.              multiple-value-call             :rhs-args       
..=              destructuring-bind              :lambda/expr    
.x.              values          :unreduce       :also-prefix    
:|.|             cons            
||               or              :unreduce       
or               or              :unreduce       :also-prefix    
&amp;&amp;               and             :unreduce       
and              and             :unreduce       :also-prefix    
&lt;                &lt;               :unreduce       :also-prefix    
&gt;                &gt;               :unreduce       :also-prefix    
&lt;=               &lt;=              :unreduce       :also-prefix    
&gt;=               &gt;=              :unreduce       :also-prefix    
===              equalp          
equalp           equalp          
equal            equal           
==               eql             
eql              eql             :also-prefix    
=s=              string=         
=c=              char=           :unreduce       
=                =               :unreduce       :also-prefix    
/=               /=              :unreduce       :also-prefix    
eq               eq              
subtypep         subtypep        
in               member          
coerce           coerce          
elt              elt             
svref            svref           
!!               aref            
binfix::+.       logior          :unreduce       
binfix::-.       logxor          :unreduce       
binfix::*.       logand          :unreduce       
&lt;&lt;               ash             
mod              mod             
min              min             :also-prefix    :unreduce       
max              max             :also-prefix    :unreduce       
+                +               :also-unary     :unreduce       
-                -               :also-unary     :unreduce       
floor            floor           
ceiling          ceiling         
truncate         truncate        
/                /               :also-unary     
*                *               :also-prefix    :unreduce       
**               expt            
!                aref            :rhs-args       
|;|              |;|             
------------------------------------------------------------
</code></pre>

<p>=> <code>nil</code></p>
